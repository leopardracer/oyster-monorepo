{"author":"Marlin Labs","title":"Certificate-verification and payout-handling contract","fileName":"/contracts/Certificate.sol","name":"Certificate","abi":[{"constant":false,"inputs":[{"name":"_offerId","type":"bytes32"},{"name":"_publisher","type":"address"},{"name":"_client","type":"address"},{"name":"_max","type":"uint8"},{"name":"_nonce","type":"uint8"},{"name":"_vArray","type":"uint8[3]"},{"name":"_rArray","type":"bytes32[3]"},{"name":"_sArray","type":"bytes32[3]"}],"name":"settleWinningCertificate","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_tokenContractAddress","type":"address"},{"name":"_uploadContractAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.24;\n\nimport \"./library/CertificateVerifier.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\ncontract UploadInterface {\n    function readStake(address _node) public constant returns (uint256);\n    function readPublisherOffer(bytes32 _id) public constant returns (address, string, string, uint256, uint256, uint256, uint256, uint256, uint256);\n}\n\n/**\n@title Certificate-verification and payout-handling contract\n@author Marlin Labs\n@notice Master nodes/storage nodes can fetch rewards for their certificates\n*/\ncontract Certificate {\n\n    using CertificateVerifier for CertificateVerifier;\n    using CertificateVerifier for CertificateVerifier.ReplayProtectionStruct;\n\n    string constant SIGNED_MSG_WIN_PREFIX = \"\\x19Ethereum Signed Message:\\n65\";\n    address MARLIN_TOKEN_ADDRESS;\n    address MARLIN_UPLOAD_CONTRACT_ADDRESS;\n\n    CertificateVerifier.ReplayProtectionStruct serviceCerts;\n\n    /**\n    @notice Constructor that sets the Marlin token contract address and Publisher-side Upload contract address\n    @param _tokenContractAddress Address of the Marlin token contract\n    @param _uploadContractAddress Address of the publisher-side Upload contract\n    */\n    constructor(address _tokenContractAddress, address _uploadContractAddress) public {\n        MARLIN_TOKEN_ADDRESS = _tokenContractAddress;\n        MARLIN_UPLOAD_CONTRACT_ADDRESS = _uploadContractAddress;\n    }\n\n    /**\n    @notice Function to be called to fetch reward for delivery certificate\n    @param _offerId ID of the publisher offer from the Upload contract\n    @param _publisher Address of the publisher who created the offer\n    @param _client Address of the master node\n    @param _max Max certificates\n    @param _nonce Nonce of this txn\n    @param _vArray Array of the recovery IDs of the signatures\n    @param _rArray Array of the r-value of ECDSA signatures\n    @param _sArray Array of the s-value of ECDSA signatures\n    @return {\n      \"_success\": \"Boolean, true if the payout was successful\"\n    }\n    */\n    function settleWinningCertificate(\n        bytes32 _offerId,\n        address _publisher,\n        address _client,\n        uint8 _max,\n        uint8 _nonce,\n        uint8[3] _vArray,\n        bytes32[3] _rArray,\n        bytes32[3] _sArray\n    )\n        public\n        returns (bool _success)\n    {\n        // make sure service certificate is not re-used\n        bytes32 _servCertHashed = keccak256(abi.encodePacked(_vArray[1], _rArray[1], _sArray[1]));\n        require(serviceCerts.isServiceCertUsed(_servCertHashed) == false);\n        serviceCerts.used[_servCertHashed] = true;\n\n        require(isWinningCertificate(\n            _publisher,\n            _client,\n            _max,\n            _nonce,\n            _vArray,\n            _rArray,\n            _sArray,\n            msg.sender\n        ));\n\n        // fetch delivery reward from upload contract\n        uint256 _deliveryReward;\n        (,,,,_deliveryReward,,,,) = UploadInterface(MARLIN_UPLOAD_CONTRACT_ADDRESS).readPublisherOffer(_offerId);\n        require(ERC20(MARLIN_TOKEN_ADDRESS).transfer(msg.sender, _deliveryReward));\n\n        _success = true;\n    }\n\n    function isWinningCertificate(\n        address _publisher,\n        address _client,\n        uint8 _max,\n        uint8 _nonce,\n        uint8[3] _vArray,\n        bytes32[3] _rArray,\n        bytes32[3] _sArray,\n        address _winner\n    )\n        internal\n        pure\n        returns (bool _is)\n    {\n        require(CertificateVerifier.isValidServiceCertificate(\n            _publisher,\n            _client,\n            _max,\n            _vArray[0],\n            _rArray[0],\n            _sArray[0],\n            _nonce,\n            _vArray[1],\n            _rArray[1],\n            _sArray[1]\n        ));\n\n        bytes32 _hashedMsg = keccak256(abi.encodePacked(\n            SIGNED_MSG_WIN_PREFIX,\n            _rArray[1],\n            _sArray[1],\n            _vArray[1]\n        ));\n        address _signer = ecrecover(_hashedMsg, _vArray[2], _rArray[2], _sArray[2]);\n        _is = (_signer == _winner);\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[{"name":"_offerId","type":"bytes32","description":"ID of the publisher offer from the Upload contract"},{"name":"_publisher","type":"address","description":"Address of the publisher who created the offer"},{"name":"_client","type":"address","description":"Address of the master node"},{"name":"_max","type":"uint8","description":"Max certificates"},{"name":"_nonce","type":"uint8","description":"Nonce of this txn"},{"name":"_vArray","type":"uint8[3]","description":"Array of the recovery IDs of the signatures"},{"name":"_rArray","type":"bytes32[3]","description":"Array of the r-value of ECDSA signatures"},{"name":"_sArray","type":"bytes32[3]","description":"Array of the s-value of ECDSA signatures"}],"name":"settleWinningCertificate","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if the payout was successful"}],"payable":false,"stateMutability":"nonpayable","type":"function","return":"{ \"_success\": \"Boolean, true if the payout was successful\" }","notice":"Function to be called to fetch reward for delivery certificate","signature":"settleWinningCertificate(bytes32,address,address,uint8,uint8,uint8[3],bytes32[3],bytes32[3])","signatureHash":"ffa57d7d"},{"inputs":[{"name":"_tokenContractAddress","type":"address"},{"name":"_uploadContractAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]}
