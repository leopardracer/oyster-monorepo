{"author":"Marlin Labs","title":"Publisher-side upload offers","fileName":"/contracts/Upload.sol","name":"Upload","abi":[{"constant":false,"inputs":[],"name":"withdrawRefund","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_id","type":"bytes32"},{"name":"_node","type":"address"}],"name":"readStake","outputs":[{"name":"_value","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_node","type":"address"}],"name":"readRefund","outputs":[{"name":"_value","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_id","type":"bytes32"}],"name":"readPublisherOffer","outputs":[{"name":"_publisher","type":"address"},{"name":"_namespace","type":"string"},{"name":"_archiveUrl","type":"string"},{"name":"_storageReward","type":"uint256"},{"name":"_deliveryReward","type":"uint256"},{"name":"_validTill","type":"uint256"},{"name":"_expiry","type":"uint256"},{"name":"_replication","type":"uint256"},{"name":"_requiredStake","type":"uint256"},{"name":"_geoHash","type":"bytes32"},{"name":"_archiveSize","type":"uint256"},{"name":"_archiveHash","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32"}],"name":"servePublisherOffer","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_publisher","type":"address"}],"name":"readOffersByPublisher","outputs":[{"name":"_ids","type":"bytes32[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32"}],"name":"withdrawStake","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32"},{"name":"_replication","type":"uint256"}],"name":"scalePublisherOffer","outputs":[{"name":"_success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_namespace","type":"string"},{"name":"_archiveUrl","type":"string"},{"name":"_storageReward","type":"uint256"},{"name":"_deliveryReward","type":"uint256"},{"name":"_duration","type":"uint256"},{"name":"_expiry","type":"uint256"},{"name":"_replication","type":"uint256"},{"name":"_requiredStake","type":"uint256"},{"name":"_geoHash","type":"bytes32"},{"name":"_archiveSize","type":"uint256"},{"name":"_archiveHash","type":"bytes32"}],"name":"addPublisherOffer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_tokenContractAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"id","type":"bytes32"}],"name":"NewPublisherOffer","type":"event"}],"bin":false,"opcodes":false,"source":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n@title Publisher-side upload offers\n@author Marlin Labs\n@notice Publishers can create new offers for storing and delivering content\n*/\ncontract Upload {\n\n    using SafeMath for uint256;\n\n    event NewPublisherOffer(bytes32 id);\n\n    /**\n    @notice Struct for Publisher Offer\n    @param publisher Address of the publisher\n    @param namespace Namespace of the website/project\n    @param archiveUrl URL of the file archive\n    @param storageReward Reward (LIN) for storing this content\n    @param deliveryReward Reward (LIN) for delivering/serving this content\n    @param validTill UTC timestamp till which this offer is valid\n    @param expiry UTC timestamp at which offer auto-expires if no master nodes join\n    @param replication Replication factor of the content\n    @param requiredStake Stake (LIN) required to store/deliver this content\n    @param nodes Addresses of the master nodes that have joined this offer\n    @param activeNodes Mapping of whether an address has joined this offer or not\n    @param geoHash Geohash specifies region from which nodes can accept offer\n    @param archiveSize size of archive\n    @param archiveHash hash of archive, will be used for validation\n    */\n    struct PublisherOffer {\n        address publisher;\n        string namespace;\n        string archiveUrl;\n        uint256 storageReward;\n        uint256 deliveryReward;\n        uint256 validTill;\n        uint256 expiry;\n        uint256 replication;\n        uint256 requiredStake;\n        address[] nodes;\n        mapping(address => bool) activeNodes;\n        bytes32 geoHash;\n        uint256 archiveSize;\n        bytes32 archiveHash;\n    }\n\n    mapping(bytes32 => PublisherOffer) offers;\n    mapping(address => bytes32[]) offersByPublisher;\n    mapping(address => uint256) refunds;\n    address MARLIN_TOKEN_ADDRESS;\n\n    /**\n    @notice Constructor that saves the address of the Marlin token contract\n    @param _tokenContractAddress Address of Marlin token contract\n    */\n    constructor(address _tokenContractAddress) public {\n        MARLIN_TOKEN_ADDRESS = _tokenContractAddress;\n    }\n\n    /**\n    @notice Function to create a new publisher-side offer\n    @dev This may also be called to renew a offer whose validity was over\n    @param _namespace Namespace of the website/project\n    @param _archiveUrl URL of the file archive\n    @param _storageReward Reward (LIN) for storing this content\n    @param _deliveryReward Reward (LIN) for delivering/serving this content\n    @param _duration Duration of the offer after which its validity ends (seconds)\n    @param _expiry UTC timestamp at which offer auto-expires if no master nodes join\n    @param _replication Replication factor of the content\n    @param _requiredStake Stake (LIN) required to store/deliver this content\n    @param _geoHash geographic region from which nodes can accept this offer\n    @param _archiveSize size of archive\n    @param _archiveHash hash of archive\n    */\n    function addPublisherOffer(\n        string _namespace,\n        string _archiveUrl,\n        uint256 _storageReward,\n        uint256 _deliveryReward,\n        uint256 _duration,\n        uint256 _expiry,\n        uint256 _replication,\n        uint256 _requiredStake,\n        bytes32 _geoHash,\n        uint256 _archiveSize,\n        bytes32 _archiveHash\n    )\n        public\n    {\n        bytes32 _id = keccak256(abi.encodePacked(_namespace, _archiveUrl));\n        require(isUnique(_id));\n        require(now < _expiry);\n        require(_requiredStake > 0);\n        if (offers[_id].nodes.length > 0) {\n            require(msg.sender == offers[_id].publisher);\n            refundPublisherOffer(_id);\n        }\n        addToList(msg.sender, _id);\n        offers[_id].publisher = msg.sender;\n        offers[_id].namespace = _namespace;\n        offers[_id].archiveUrl = _archiveUrl;\n        offers[_id].storageReward = _storageReward;\n        offers[_id].deliveryReward = _deliveryReward;\n        offers[_id].validTill = now.add(_duration);\n        offers[_id].expiry = _expiry;\n        offers[_id].replication = _replication;\n        offers[_id].requiredStake = _requiredStake;\n        offers[_id].geoHash = _geoHash;\n        offers[_id].archiveSize = _archiveSize;\n        offers[_id].archiveHash = _archiveHash;\n        emit NewPublisherOffer(_id);\n    }\n\n    /**\n    @notice Function to be called by publisher to scale out/in replication factor\n    @dev Can scale in only upto the already joined number of master nodes\n    @param _id keccak256(_namespace, _archiveUrl) is the ID of the offer\n    @param _replication Replication factor of the content\n    @return {\n      \"_success\": \"Boolean, true if updated successfully\"\n    }\n    */\n    function scalePublisherOffer(\n        bytes32 _id,\n        uint256 _replication\n    )\n        public\n        returns (bool _success)\n    {\n        require(msg.sender == offers[_id].publisher);\n\n        require(offers[_id].nodes.length <= _replication);\n        offers[_id].replication = _replication;\n\n        _success = true;\n    }\n\n    /**\n    @notice Function to join a offer and deliver/serve content\n    @dev Offer can only be joined till the replication is not satisfied\n         msg.sender must approve this contract to transferFrom LIN tokens on their behalf\n    @param _id keccak256(_namespace, _archiveUrl) is the ID of the offer\n    @return {\n      \"_success\": \"Boolean, true if joined the offer successfully\"\n    }\n    */\n    function servePublisherOffer(bytes32 _id)\n        public\n        returns (bool _success)\n    {\n        // make sure upload contract is valid\n        require(offers[_id].validTill > now);\n        require(offers[_id].expiry > now);\n\n        // make sure it is a new node\n        require(offers[_id].activeNodes[msg.sender] == false);\n\n        // make sure upload contract has slots remaining, if yes, add new node\n        require(offers[_id].nodes.length < offers[_id].replication);\n        offers[_id].activeNodes[msg.sender] = true;\n        offers[_id].nodes.push(msg.sender);\n\n        // make sure transfer of tokens is possible\n        require(ERC20(MARLIN_TOKEN_ADDRESS).transferFrom(\n            msg.sender,\n            address(this),\n            offers[_id].requiredStake\n        ));\n\n        _success = true;\n    }\n\n    /**\n    @notice Leave the offer after its validity is over\n    @dev This also means the staked LIN tokens will be transferred back\n    @param _id keccak256(_namespace, _archiveUrl) is the ID of the offer\n    @return {\n      \"_success\": \"Boolean, true if withdrawn successfully\"\n    }\n    */\n    function withdrawStake(bytes32 _id)\n        public\n        returns (bool _success)\n    {\n        // make sure upload contract is not valid anymore\n        require(now > offers[_id].validTill);\n\n        // make sure this node was serving\n        require(offers[_id].activeNodes[msg.sender] == true);\n        removeNode(_id, msg.sender);\n        offers[_id].activeNodes[msg.sender] = false;\n\n        // withdraw tokens\n        require(ERC20(MARLIN_TOKEN_ADDRESS).transfer(msg.sender, offers[_id].requiredStake));\n\n        _success = true;\n    }\n\n    /**\n    @notice Function to withdraw refundable LIN tokens from this contract\n    @dev Tokens are refunded if the publisher renews their offer beyond the initial offer validity\n    */\n    function withdrawRefund()\n        public\n    {\n        uint256 _refund = refunds[msg.sender];\n        require(_refund > 0);\n        refunds[msg.sender] = 0;\n        require(ERC20(MARLIN_TOKEN_ADDRESS).transfer(msg.sender, _refund));\n    }\n\n    /**\n    @notice Function to read publisher-side offer details\n    @param _id keccak256(_namespace, _archiveUrl) is the ID of the offer\n    @return {\n      \"_publisher\": \"Address of the publisher, who created this offer\",\n      \"_namespace\": \"Namespace of the website/project\",\n      \"_archiveUrl\": \"URL of the file archive\",\n      \"_storageReward\": \"Reward (LIN) for storing this content\",\n      \"_deliveryReward\": \"Reward (LIN) for delivering/serving this content\",\n      \"_validTill\": \"UTC timestamp at which offer's validity is over\",\n      \"_expiry\": \"UTC timestamp at which offer auto-expires if no master nodes join\",\n      \"_replication\": \"Replication factor of the content\",\n      \"_requiredStake\": \"Stake (LIN) required to store/deliver this content\",\n      \"_geoHash\": \"geographic region from which nodes can accpe this offer\",\n      \"_archiveSize\": \"size of archive\",\n      \"_archiveHash\": \"hash of archive\"\n    }\n    */\n    function readPublisherOffer(bytes32 _id)\n        public\n        constant\n        returns (\n            address _publisher,\n            string _namespace,\n            string _archiveUrl,\n            uint256 _storageReward,\n            uint256 _deliveryReward,\n            uint256 _validTill,\n            uint256 _expiry,\n            uint256 _replication,\n            uint256 _requiredStake,\n            bytes32 _geoHash,\n            uint256 _archiveSize,\n            bytes32 _archiveHash\n        )\n    {\n        _publisher = offers[_id].publisher;\n        _namespace = offers[_id].namespace;\n        _archiveUrl = offers[_id].archiveUrl;\n        _storageReward = offers[_id].storageReward;\n        _deliveryReward = offers[_id].deliveryReward;\n        _validTill = offers[_id].validTill;\n        _expiry = offers[_id].expiry;\n        _replication = offers[_id].replication;\n        _requiredStake = offers[_id].requiredStake;\n        _geoHash = offers[_id].geoHash;\n        _archiveSize = offers[_id].archiveSize;\n        _archiveHash = offers[_id].archiveHash;\n    }\n\n    /**\n    @notice Function to read the offers owned by a publisher\n    @param _publisher Address of the publisher\n    @return {\n      \"_ids\": \"Array of bytes (IDs) of offers\"\n    }\n    */\n    function readOffersByPublisher(address _publisher)\n        public\n        constant\n        returns (bytes32[] _ids)\n    {\n        _ids = offersByPublisher[_publisher];\n    }\n\n    /**\n    @notice Function to read the refund value of a master node\n    @param _node Address of the master node\n    @return {\n      \"_value\": \"Refund value of the master node\"\n    }\n    */\n    function readRefund(address _node)\n        public\n        constant\n        returns (uint256 _value)\n    {\n        _value = refunds[_node];\n    }\n\n    /**\n    @notice Function to read the stake of a master node for specific offer\n    @param _id keccak256(_namespace, _archiveUrl) is the ID of the offer\n    @param _node Address of the master node\n    @return {\n      \"_value\": \"LIN tokens staked by the master node for this offer\"\n    }\n    */\n    function readStake(bytes32 _id, address _node)\n        public\n        constant\n        returns (uint256 _value)\n    {\n        if (offers[_id].activeNodes[_node] == true) {\n            _value = offers[_id].requiredStake;\n        }\n    }\n\n    function addToList(address _publisher, bytes32 _id)\n        internal\n    {\n        if (!isInList(offersByPublisher[_publisher], _id)) {\n            offersByPublisher[_publisher].push(_id);\n        }\n    }\n\n    function isInList(bytes32[] _list, bytes32 _item)\n        internal\n        pure\n        returns (bool _success)\n    {\n        uint256 _length = _list.length;\n        for (uint256 _i = 0; _i < _length; _i++) {\n            if (_item == _list[_i]) {\n                _success = true;\n                break;\n            }\n        }\n    }\n\n    function refundPublisherOffer(bytes32 _id)\n        internal\n    {\n        // make sure upload contract is not valid anymore\n        require(now > offers[_id].validTill);\n\n        address[] memory _nodes = offers[_id].nodes;\n        for (uint256 i = _nodes.length; i > 0; i--) {\n            address _node = _nodes[i];\n            refunds[_node] = refunds[_node].add(offers[_id].requiredStake);\n            removeNode(_id, _node);\n            offers[_id].activeNodes[_node] = false;\n        }\n    }\n\n    function removeNode(bytes32 _id, address _node)\n        internal\n        constant\n    {\n        address[] memory _nodes = offers[_id].nodes;\n        for (uint256 i = _nodes.length; i > 0; i--) {\n            if (_nodes[i] == _node) {\n                delete _nodes[i];\n                break;\n            }\n        }\n    }\n\n    function isUnique(bytes32 _id)\n        internal\n        constant\n        returns (bool _is)\n    {\n        if (\n            (now > offers[_id].expiry) ||\n            (offers[_id].expiry == 0) ||\n            (now > offers[_id].validTill)\n        ) {\n            return true;\n        }\n        return false;\n    }\n}\n","abiDocs":[{"constant":false,"inputs":[],"name":"withdrawRefund","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Tokens are refunded if the publisher renews their offer beyond the initial offer validity","notice":"Function to withdraw refundable LIN tokens from this contract","signature":"withdrawRefund()","signatureHash":"110f8874"},{"constant":true,"inputs":[{"name":"_id","type":"bytes32","description":"keccak256(_namespace, _archiveUrl) is the ID of the offer"},{"name":"_node","type":"address","description":"Address of the master node"}],"name":"readStake","outputs":[{"name":"_value","type":"uint256","description":"LIN tokens staked by the master node for this offer"}],"payable":false,"stateMutability":"view","type":"function","return":"{ \"_value\": \"LIN tokens staked by the master node for this offer\" }","notice":"Function to read the stake of a master node for specific offer","signature":"readStake(bytes32,address)","signatureHash":"134358b7"},{"constant":true,"inputs":[{"name":"_node","type":"address","description":"Address of the master node"}],"name":"readRefund","outputs":[{"name":"_value","type":"uint256","description":"Refund value of the master node"}],"payable":false,"stateMutability":"view","type":"function","return":"{ \"_value\": \"Refund value of the master node\" }","notice":"Function to read the refund value of a master node","signature":"readRefund(address)","signatureHash":"23bb2dea"},{"constant":true,"inputs":[{"name":"_id","type":"bytes32","description":"keccak256(_namespace, _archiveUrl) is the ID of the offer"}],"name":"readPublisherOffer","outputs":[{"name":"_publisher","type":"address","description":"Address of the publisher, who created this offer"},{"name":"_namespace","type":"string","description":"Namespace of the website/project"},{"name":"_archiveUrl","type":"string","description":"URL of the file archive"},{"name":"_storageReward","type":"uint256","description":"Reward (LIN) for storing this content"},{"name":"_deliveryReward","type":"uint256","description":"Reward (LIN) for delivering/serving this content"},{"name":"_validTill","type":"uint256","description":"UTC timestamp at which offer's validity is over"},{"name":"_expiry","type":"uint256","description":"UTC timestamp at which offer auto-expires if no master nodes join"},{"name":"_replication","type":"uint256","description":"Replication factor of the content"},{"name":"_requiredStake","type":"uint256","description":"Stake (LIN) required to store/deliver this content"},{"name":"_geoHash","type":"bytes32","description":"geographic region from which nodes can accpe this offer"},{"name":"_archiveSize","type":"uint256","description":"size of archive"},{"name":"_archiveHash","type":"bytes32","description":"hash of archive"}],"payable":false,"stateMutability":"view","type":"function","return":"{ \"_publisher\": \"Address of the publisher, who created this offer\", \"_namespace\": \"Namespace of the website/project\", \"_archiveUrl\": \"URL of the file archive\", \"_storageReward\": \"Reward (LIN) for storing this content\", \"_deliveryReward\": \"Reward (LIN) for delivering/serving this content\", \"_validTill\": \"UTC timestamp at which offer's validity is over\", \"_expiry\": \"UTC timestamp at which offer auto-expires if no master nodes join\", \"_replication\": \"Replication factor of the content\", \"_requiredStake\": \"Stake (LIN) required to store/deliver this content\", \"_geoHash\": \"geographic region from which nodes can accpe this offer\", \"_archiveSize\": \"size of archive\", \"_archiveHash\": \"hash of archive\" }","notice":"Function to read publisher-side offer details","signature":"readPublisherOffer(bytes32)","signatureHash":"2b611c49"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32","description":"keccak256(_namespace, _archiveUrl) is the ID of the offer"}],"name":"servePublisherOffer","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if joined the offer successfully"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Offer can only be joined till the replication is not satisfied msg.sender must approve this contract to transferFrom LIN tokens on their behalf","return":"{ \"_success\": \"Boolean, true if joined the offer successfully\" }","notice":"Function to join a offer and deliver/serve content","signature":"servePublisherOffer(bytes32)","signatureHash":"9e0cd016"},{"constant":true,"inputs":[{"name":"_publisher","type":"address","description":"Address of the publisher"}],"name":"readOffersByPublisher","outputs":[{"name":"_ids","type":"bytes32[]","description":"Array of bytes (IDs) of offers"}],"payable":false,"stateMutability":"view","type":"function","return":"{ \"_ids\": \"Array of bytes (IDs) of offers\" }","notice":"Function to read the offers owned by a publisher","signature":"readOffersByPublisher(address)","signatureHash":"ace64325"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32","description":"keccak256(_namespace, _archiveUrl) is the ID of the offer"}],"name":"withdrawStake","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if withdrawn successfully"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This also means the staked LIN tokens will be transferred back","return":"{ \"_success\": \"Boolean, true if withdrawn successfully\" }","notice":"Leave the offer after its validity is over","signature":"withdrawStake(bytes32)","signatureHash":"b95ff689"},{"constant":false,"inputs":[{"name":"_id","type":"bytes32","description":"keccak256(_namespace, _archiveUrl) is the ID of the offer"},{"name":"_replication","type":"uint256","description":"Replication factor of the content"}],"name":"scalePublisherOffer","outputs":[{"name":"_success","type":"bool","description":"Boolean, true if updated successfully"}],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Can scale in only upto the already joined number of master nodes","return":"{ \"_success\": \"Boolean, true if updated successfully\" }","notice":"Function to be called by publisher to scale out/in replication factor","signature":"scalePublisherOffer(bytes32,uint256)","signatureHash":"d735fd9d"},{"constant":false,"inputs":[{"name":"_namespace","type":"string","description":"Namespace of the website/project"},{"name":"_archiveUrl","type":"string","description":"URL of the file archive"},{"name":"_storageReward","type":"uint256","description":"Reward (LIN) for storing this content"},{"name":"_deliveryReward","type":"uint256","description":"Reward (LIN) for delivering/serving this content"},{"name":"_duration","type":"uint256","description":"Duration of the offer after which its validity ends (seconds)"},{"name":"_expiry","type":"uint256","description":"UTC timestamp at which offer auto-expires if no master nodes join"},{"name":"_replication","type":"uint256","description":"Replication factor of the content"},{"name":"_requiredStake","type":"uint256","description":"Stake (LIN) required to store/deliver this content"},{"name":"_geoHash","type":"bytes32","description":"geographic region from which nodes can accept this offer"},{"name":"_archiveSize","type":"uint256","description":"size of archive"},{"name":"_archiveHash","type":"bytes32","description":"hash of archive"}],"name":"addPublisherOffer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"This may also be called to renew a offer whose validity was over","notice":"Function to create a new publisher-side offer","signature":"addPublisherOffer(string,string,uint256,uint256,uint256,uint256,uint256,uint256,bytes32,uint256,bytes32)","signatureHash":"dfa90343"},{"inputs":[{"name":"_tokenContractAddress","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"id","type":"bytes32"}],"name":"NewPublisherOffer","type":"event","signature":"NewPublisherOffer(bytes32)","signatureHash":"91e5f002"}]}
